var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introductory","text":"<p>Welcome to Junior/Full L2 Docs Pages!</p> <p>This page was created with the hopes of helping both new and experienced technicians advance their knowledge and accelerate their salary increases.</p>"},{"location":"FTP.html","title":"FTP","text":"<p>FTP is a\u00a0protocol that relies on two communications channels between the client and server: a command channel for controlling the conversation and a data channel for transmitting file content.</p> <p>FTP transfer process: 1. A user typically needs to log on to the\u00a0FTP server, although some servers make some or all of their content available without a login, a model known as\u00a0_anonymous FTP 2. The client initiates a conversation with the server when the user requests to download a file. 3. Using FTP, a client can upload, download, delete, rename, move and copy files on a server.</p> <p>Users can work with FTP via a simple command-line interface -- terminal -- or with a dedicated graphical user interface.  Most common client is  FileZilla that supports FTP, FTPS and SFTP, but web browsers can also serve as FTP clients. There are several different ways an FTP server and client software can conduct a file transfer using FTP:</p> <ul> <li>Anonymous FTP.\u00a0This is the most basic form of FTP. It provides support for data transfers without encrypting data or using a username and password. It's most commonly used for download of material that is allowed for unrestricted distribution. </li> <li>Password-protected FTP.\u00a0This is also a basic FTP service, but it requires the use of a username and password, though the service might not be encrypted or secure. It also works on port 21.</li> <li>FTP Secure (FTPS) is an extension of FTP that adds security through the use of Transport Layer Security (TLS) or Secure Sockets Layer (SSL) encryption. It provides an additional layer of protection by encrypting the control and data connections, preventing unauthorized access and data interception. FTPS can use either implicit SSL/TLS (FTPIS) or explicit SSL/TLS (FTPS). Implicit FTPS requires SSL/TLS encryption from the start, while explicit FTPS allows the client and server to negotiate encryption after the initial connection. It typically defaults to using port 990.</li> <li>Secure FTP (SFTP) - This is technically not an FTP protocol, but it functions similarly. Rather, SFTP is a subset of the Secure Shell (SSH) protocol that runs over port 22. SSH is commonly used by systems administrators to remotely and securely access systems and applications, and SFTP provides a mechanism within SSH for secure file transfer.</li> </ul> <p>By default, FTP does not encrypt traffic, and individuals can capture packets to read usernames, passwords and other data. By encrypting FTP with FTPS data is protected, limiting the ability of an attacker to eavesdrop on a connection and steal data.</p>"},{"location":"HTTP-HTTPS.html","title":"HTTP/HTTPS","text":""},{"location":"HTTP-HTTPS.html#http","title":"HTTP","text":"<p>Hypertext transfer protocol is a\u00a0protocol\u00a0used for transferring HTML documentations over the internet. It is a client-server protocol, which means requests are initiated by the recipient, usually the Web browser. Clients and servers communicate by exchanging individual messages. The messages sent by the client, usually a Web browser, are called\u00a0requests\u00a0and the messages sent by the server as an answer are called\u00a0responses.</p> <p>To display a Web page, the browser sends an original request to fetch the HTML document that represents the webpage. A server will accept the request and access port 80 which is reserved for HTTP requests and serve the file to the user-agent. The Web browser then combines these resources to present the complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</p> <p>HTTP is a stateless protocol:</p> <p>HTTP that is the actual transport protocol between the server and the client -- is \"stateless\" because it remembers nothing between invocations.\u00a0EVERY\u00a0resource that is accessed via HTTP is a single request with no threaded connection between them. If you load a web page with an HTML file that within it contains three\u00a0<code>&lt;img&gt;</code>\u00a0tags hitting the same server, there will be four TCP connections negotiated and opened, four data transfers, four connections closed. There is simply no state kept at the server\u00a0at the\u00a0protocol\u00a0level\u00a0that will have the server know anything about you as you come in.</p> <p>Almost anything you want to do other than viewing static web pages will involve sessions and states. When HTTP is used for its original purpose (sharing static information like scientific papers) the stateless protocol makes a lot of sense. When you start using it for things like web applications, online stores, etc. then statelessness starts to be a bother because these are inherently stateful activities. As a result people very rapidly came up with ways to slather state on top of the stateless protocol. These mechanisms have included things like cookies, like encoding state in the URLs and having the server dynamically fire up data based on those, like hidden state requests</p>"},{"location":"HTTP-HTTPS.html#https-hypertext-transfer-protocol-secure","title":"HTTPS - hypertext transfer protocol secure.","text":"<p>The issue with HTTP is that it does not encrypt the packages when a client is communicating with the server. This means that anyone who has an access to that network can read the information that is being transmitted, such as passwords, credit card numbers etc. In order to protect users from man-in-the-middle attacks, we use HTTPS. </p> <p>HTTPS uses an TLS/SSL encryption in order to randomize the text being transferred and hide the contents of the communication. This type of security system uses two different keys to encrypt communications between two parties: 1. The private key - this key is controlled by the owner of a website and it\u2019s kept, as the reader may have speculated, private. This key lives on a web server and is used to decrypt information encrypted by the public key. 2. The public key - this key is available to everyone who wants to interact with the server in a way that\u2019s secure. Information that\u2019s encrypted by the public key can only be decrypted by the private key. HTTPS uses port 443</p>"},{"location":"HTTP-HTTPS.html#http-response-codes","title":"HTTP RESPONSE CODES:","text":"<p>All HTTP response status codes are separated into five classes or categories. The first digit of the status code defines the class of response, while the last two digits do not have any classifying or categorization role. There are five classes defined by the standard:</p> <ul> <li>1xx informational response\u00a0\u2013 the request was received, continuing process</li> <li>2xx successful\u00a0\u2013 the request was successfully received, understood, and accepted</li> <li>3xx redirection\u00a0\u2013 further action needs to be taken in order to complete the request</li> <li>4xx client error\u00a0\u2013 the request contains bad syntax or cannot be fulfilled</li> <li>5xx server error\u00a0\u2013 the server failed to fulfill an apparently valid request</li> </ul> <p>Common response codes: - 200 - Ok - 300 - Multiple choices - 301 - Moved Permanently - 302 - Found - 400 - Bad request - 401 - Unauthorized - 403 - Forbidden - 404 - Not Found - 408 - Request Timeout - 418 - I'm a teapot - 429 - Too many requests - 444 - No Response - 500 - Internal Server Error - 502 - Bad Gateway - 503 - Service Unavailable - 504 - Gateway Timeout</p>"},{"location":"TCP-vs-UDP.html","title":"TCP","text":"<p>Transmission Control Protocol is a connection-oriented protocol where a stable connection is established between a client and a server before data can be sent. The data transmitted by TCP protocol is in the form of continuous datastreams.</p> <p>TCP protocol operation is divided into three phases: - Connection establishment - Data transfer - Connection termination</p>"},{"location":"TCP-vs-UDP.html#connection-establishment-three-way-handshake","title":"Connection establishment (Three-way handshake):","text":"<p>Before a client attempts to connect with a server, the server must first bind to and listen at a port to open it up for connections: this is called a passive open. Once the passive open is established, a client may establish a connection by initiating an active open using the three-way (or 3-step) handshake.</p> <p>TCP segment will have a header attached to it which will list out a source and destination port, a segment sequence number and a flag which is used to provide additional information regarding data transfer. In case of a 3-way handshake, we deal with following flgs:</p> <ol> <li>SYN: The active open is performed by the client sending a SYN (synchronize) to the server. The client sets the segment's sequence number to a random value A.</li> <li>SYN-ACK: In response, the server replies with a SYN-ACK (synchronize-acknowledge). The acknowledgment number is set to one more than the received sequence number i.e. A+1, and the sequence number that the server chooses for the packet is another random number, B.</li> <li>ACK: Finally, the client sends an ACK (acknowledge) back to the server. The sequence number is set to the received acknowledgment value i.e. A+1, and the acknowledgment number is set to one more than the received sequence number i.e. B+1.</li> </ol> <p>Steps 1 and 2 establish and acknowledge the sequence number for one direction (client to server). Steps 2 and 3 establish and acknowledge the sequence number for the other direction (server to client). Following the completion of these steps, both the client and server have received acknowledgments and a full-duplex communication is established.</p>"},{"location":"TCP-vs-UDP.html#data-transfer","title":"Data transfer","text":"<p>The Transmission Control Protocol differs in several key features compared to the User Datagram Protocol:</p> <ul> <li>Ordered data transfer: the destination host rearranges segments according to a sequence number</li> <li>Retransmission of lost packets: any cumulative stream not acknowledged is retransmitted</li> <li>Error-free data transfer: corrupted packets are treated as lost and are retransmitted</li> <li>Flow control: limits the rate a sender transfers data to guarantee reliable delivery. The receiver continually hints the sender on how much data can be received. When the receiving host's buffer fills, the next acknowledgment suspends the transfer and allows the data in the buffer to be processed.</li> <li>Congestion control: lost packets (presumed due to congestion) trigger a reduction in data delivery rate</li> </ul>"},{"location":"TCP-vs-UDP.html#connection-termination","title":"Connection termination","text":"<p>The connection termination phase uses a four-way handshake, with each side of the connection terminating independently. When an endpoint wishes to stop its half of the connection, it transmits a FIN packet, which the other end acknowledges with an ACK. Therefore, a typical tear-down requires a pair of FIN and ACK segments from each TCP endpoint. After the side that sent the first FIN has responded with the final ACK, it waits for a timeout before finally closing the connection, during which time the local port is unavailable for new connections; this state lets the TCP client resend the final acknowledgment to the server in case the ACK is lost in transit. </p> <p>The time duration is implementation-dependent, but some common values are 30 seconds, 1 minute, and 2 minutes. After the timeout, the client enters the CLOSED state and the local port becomes available for new connections.</p> <p>It is also possible to terminate the connection by a 3-way handshake, when host A sends a FIN and host B replies with a FIN &amp; ACK (combining two steps into one) and host A replies with an ACK.</p> <p>Source: https://en.wikipedia.org/wiki/Transmission_Control_Protocol</p>"},{"location":"TCP-vs-UDP.html#udp","title":"UDP","text":"<p>UDP is the \u201cfire and forget\u201d type of a protocol. It uses a connectionless communication model with a minimum of protocol mechanisms. </p> <p>UDP datagram header doesn\u2019t possess any of the extra fields TCP segment headers carry to make sure the data is received intact. The trade-off is that a transmission of data is far faster because more data can be packed into a datagram. As such, UDP is utilized in cases where speed is preferable to stability.</p> <p>UDP works best when you have a lot of data that doesn\u2019t need to be perfect or when the systems are so close to each other that the chances of a problem occurring are too small to bother worrying about. A few dropped frames on a Voice over IP call, for example, won\u2019t make much difference in the communication between two people. </p> <p>Two of the most important networking protocols, Domain Name System (DNS) and Dynamic Host Configuration Protocol (DHCP) also use UDP. </p> <p>DHCP uses UDP because DHCP server can\u2019t assume another computer is ready on either side of the session, so each step of a DHCP session just sends the information for that step without any confirmation. </p> <p>Sending a connectionless datagram also makes sense because the client won\u2019t have an IP address to begin the three-way hand-shake. DHCP uses two port numbers: DHCP clients use port 68 for sending data to and receiving data from the DHCP server, and DHCP servers use port 67 for sending and receiving data to and from DHCP clients.</p>"},{"location":"cloudsites.html","title":"Why???!1 DEAR GOD WHHYYYYY???!","text":""},{"location":"dns.html","title":"DNS (Domain Name System)","text":"<p>Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.</p> <p>The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.</p>"},{"location":"dns.html#dns-lookup","title":"DNS lookup","text":"<ol> <li>A DNS lookup typically refers to the process of converting easy to remember names called domain names (like www.google.com) into numbers called IP addresses (like 192.168.2.1). A user types the URL example.com into their web browser.     1.1. Browser cache, device cache, hosts file, router and ISP cache</li> <li>The user\u2019s computer sends a request to the recursive resolver.</li> <li>The recursive resolver then sends a request to the root nameserver which provides the address . of the TLD nameserver responsible for .com domain names.</li> <li>The root nameserver returns the result of the TLD nameserver to the recursive resolver.</li> <li>The recursive resolver sends a request to the .com TLD nameserver which provides the address of the authoritative nameserver responsible for the example.com domain.</li> <li>The TLD nameserver returns the result of the authoritative nameserver to the recursive resolver.</li> <li>The recursive resolver sends a request to the authoritative nameserver responsible for example.com which provides the DNS records requested.</li> <li>The authoritative nameserver returns results to the recursive resolver.</li> <li>The recursive resolver returns DNS records containing the IP address to the browser.</li> <li>The browser makes a request directly to the IP address of the server hosting the website.</li> </ol>"},{"location":"dns.html#host-file","title":"Host file","text":"<p>A hosts file which is used by operating systems to map a connection between an IP address and domain names before going to domain name servers. This file is a simple text file with the mapping of IPs and domain names. Can override DNS and redirect URLs or IP addresses to different locations. </p>"},{"location":"dns.html#dns-servers","title":"DNS servers","text":""},{"location":"dns.html#dns-recursor-recursive-resolver","title":"DNS recursor - recursive resolver","text":"<p>The recursive resolver server is designed to receive browser queries and is in charge of adding new ones.</p> <p>The recursor can be thought of as a librarian who is asked to go find a particular book somewhere in a library. The DNS recursor is a server designed to receive queries from client machines through applications such as web browsers. Typically the recursor is then responsible for making additional requests in order to satisfy the client\u2019s DNS query. A recursive resolver (also known as a DNS recursor) is the first stop in a DNS query. The recursive resolver acts as a middleman between a client and a DNS nameserver. After receiving a DNS query from a web client, a recursive resolver will either respond with cached data, or send a request to a root nameserver, followed by another request to a TLD nameserver, and then one last request to an authoritative nameserver. After receiving a response from the authoritative nameserver containing the requested IP address, the recursive resolver then sends a response to the client. During this process, the recursive resolver will cache information received from authoritative nameservers. When a client requests the IP address of a domain name that was recently requested by another client, the resolver can circumvent the process of communicating with the nameservers, and just deliver the client the requested record from its cache. Most Internet users use a recursive resolver provided by their ISP.</p>"},{"location":"dns.html#root-nameserver","title":"Root nameserver","text":"<p>Used as reference and points to other specific locations.</p> <p>The root server is the first step in translating (resolving) human readable host names into IP addresses. It can be thought of like an index in a library that points to different racks of books - typically it serves as a reference to other more specific locations. The 13 DNS root nameservers are known to every recursive resolver, and they are the first stop in a recursive resolver\u2019s quest for DNS records. A root server accepts a recursive resolver\u2019s query which includes a domain name, and the root nameserver responds by directing the recursive resolver to a TLD nameserver, based on the extension of that domain (.com, .net, .org, etc.). The root nameservers are overseen by a nonprofit called the Internet Corporation for Assigned Names and Numbers (ICANN). Note that while there are 13 root nameserver hostnames, that does not mean that there are only 13 machines in the root nameserver system. There are 13 types of root nameservers, but there are multiple copies of each one all over the world, which use Anycast routing to provide speedy responses. If you added up all the instances of root nameservers, you\u2019d have over 600 different servers.</p>"},{"location":"dns.html#tld-nameserver","title":"TLD nameserver","text":"<p>Contains info on TLD (.com, .net\u2026) </p> <p>The top level domain server (TLD) can be thought of as a specific rack of books in a library. This nameserver is the next step in the search for a specific IP address, and it hosts the last portion of a hostname (In example.com, the TLD server is \u201ccom\u201d). A TLD nameserver maintains information for all the domain names that share a common domain extension, such as .com, .net, or whatever comes after the last dot in a URL. For example, a .com TLD nameserver contains information for every website that ends in \u2018.com\u2019. If a user was searching for google.com, after receiving a response from a root nameserver, the recursive resolver would then send a query to a .com TLD nameserver, which would respond by pointing to the authoritative nameserver (see below) for that domain.</p> <ul> <li>Generic top-level domains: These are domains that are not country specific, some of the best-known generic TLDs include .com, .org, .net, .edu, and .gov.</li> <li>Country code top-level domains: These include any domains that are specific to a country or state. Examples include .uk, .us, .ru, and .jp.</li> </ul>"},{"location":"dns.html#authoritative-nameserver","title":"Authoritative nameserver","text":"<p>Should have info on the requested site (it contains the DNS zone).</p> <p>This final nameserver can be thought of as a dictionary on a rack of books, in which a specific name can be translated into its definition. The authoritative nameserver is the last stop in the nameserver query. If the authoritative name server has access to the requested record, it will return the IP address for the requested hostname back to the DNS Recursor (the librarian) that made the initial request. When a recursive resolver receives a response from a TLD nameserver, that response will direct the resolver to an authoritative nameserver. The authoritative nameserver is usually the resolver\u2019s last step in the journey for an IP address. The authoritative nameserver contains information specific to the domain name it serves (e.g. google.com) and it can provide a recursive resolver with the IP address of that server found in the DNS A record, or if the domain has a CNAME record (alias) it will provide the recursive resolver with an alias domain, at which point the recursive resolver will have to perform a whole new DNS lookup to procure a record from an authoritative nameserver (often an A record containing an IP address). </p> <p>https://www.cloudflare.com/learning/dns/dns-server-types/ </p>"},{"location":"dns.html#dns-records","title":"DNS records","text":""},{"location":"dns.html#a-record","title":"A record","text":"<p>The record that holds the IP address of a domain. The \"A\" stands for \"address\" and this is the most fundamental type of DNS record: it indicates the IP address of a given domain. The most common usage of A records is IP address lookups: matching a domain name (like \"cloudflare.com\") to an IPv4 address. This enables a user's device to connect with and load a website, without the user memorizing and typing in the actual IP address. </p> <ul> <li>DNS AAAA records match a domain name to an IPv6 address. DNS AAAA records are exactly like DNS A records, except that they store a domain's IPv6 address instead of its IPv4 address.</li> </ul>"},{"location":"dns.html#cname-record","title":"CNAME record","text":"<p>Forwards one domain or subdomain to another domain, does NOT provide an IP address.  The \u2018canonical name\u2019 (CNAME) record is used in lieu (in substitution) of an A record, when a domain or subdomain is an alias of another domain. All CNAME records must point to a domain, never to an IP address. </p> <ul> <li>CNAME restrictions - MX and NS records cannot point to a CNAME record; they have to point to an A record (for IPv4) or an AAAA record (for IPv6). </li> </ul>"},{"location":"dns.html#mx-record","title":"MX record","text":"<p>An MX record is a mail exchange record that directs email to a mail server. The MX record indicates how email messages should be routed in accordance with the Simple Mail Transfer Protocol (SMTP, the standard protocol for all email). Like CNAME records, an MX record must always point to another domain.</p>"},{"location":"dns.html#txt-record","title":"TXT record","text":"<p>Lets an admin store text notes in the record. These records are often used for email security. Today, two of the most important uses for DNS TXT records are email spam prevention and domain ownership verification, although TXT records were not designed for these uses originally. One domain can have many TXT records.</p> <p>Together, DMARC, DKIM, and SPF function like a background check on email senders, to make sure they really are who they say they are.</p>"},{"location":"dns.html#spf-record","title":"SPF record","text":"<p>A sender policy framework (SPF) record is a type of DNS TXT record that lists all the servers authorized to send emails from a particular domain. https://www.proofpoint.com/us/threat-reference/spf</p>"},{"location":"dns.html#dkim-record","title":"DKIM record","text":"<p>DomainKeys Identified Mail (DKIM) is a method of email authentication that helps prevent spammers and other malicious parties from impersonating a legitimate domain. https://www.proofpoint.com/us/threat-reference/dkim</p>"},{"location":"dns.html#dmarc","title":"DMARC","text":"<p>Domain-based Message Authentication Reporting and Conformance (DMARC) is a method of authenticating email messages. A DMARC policy tells a receiving email server what to do after checking a domain's Sender Policy Framework (SPF) and DomainKeys Identified Mail (DKIM) records.</p>"},{"location":"dns.html#ns-record","title":"NS record","text":"<p>NS stands for \u2018nameserver,\u2019 and the nameserver record indicates which DNS server is authoritative for that domain (i.e. which server contains the actual DNS records). Basically, NS records tell the Internet where to go to find out a domain's IP address. A domain often has multiple NS records which can indicate primary and secondary nameservers for that domain. Without properly configured NS records, users will be unable to load a website or application.</p>"},{"location":"dns.html#soa-record","title":"SOA record","text":"<p>\u2018Start of authority\u2019 (SOA) record stores important information about a domain or zone such as name of a primary DNS server (hostname of the primary DNS server for the zone, and it should contain a matching NS record), the email address of the administrator, when the domain was last updated, serial number (used by secondary DNS servers to check if the zone has changed), and how long the server should wait between refreshes.</p> <p>Every DNS database file begins with a Start of Authority (SOA) resource record. Whenever you alter any data in a DNS database file, you must increment the SOA serial number by one integer.</p> <p>For example, if the current SOA Serial Number in a data file is 101, and you make a change to the file's data, you must change 101 to 102. If you don't change the SOA serial number, the domain's slave servers do not update their copy of the database files with the new information. The master and slave servers would then be out of sync.</p>"},{"location":"dns.html#srv-record","title":"SRV record","text":"<p>The DNS \"service\" (SRV) record specifies a host and port for specific services such as voice over IP (VoIP), instant messaging, and so on. Most other DNS records only specify a server or an IP address, but SRV records include a port at that IP address as well. Some Internet protocols require the use of SRV records in order to function.</p>"},{"location":"dns.html#ptr-record","title":"PTR record","text":"<p>Provides a domain name in reverse-lookups.  A DNS pointer record (PTR for short) provides the domain name associated with an IP address. A DNS PTR record is exactly the opposite of the 'A' record, which provides the IP address associated with a domain name. DNS PTR records are used in reverse DNS lookups. PTR records store IP addresses with their segments reversed, and they append \".in-addr.arpa\" to that. </p> <p>For example if a domain has an IP address of 192.0.2.1, the PTR record will store the domain's information under 1.2.0.192.in-addr.arpa.</p>"},{"location":"dns.html#glue-record","title":"GLUE record","text":"<p>Glue records are DNS records created at the domain\u2019s registrar. The record provides a complete answer when the TLD nameserver returns a reference for an authoritative nameserver for a domain.  Creating a glue record, an A record served by the TLD nameserver, avoids circular references and allows for both DNS name resolution and listing the nameservers inside the domain itself. Glue records can only be created at the domain registrar as the registrar controls the DNS settings for a given domain\u2019s delegation. Every nameserver on the internet has its own glue record created by the domain\u2019s owner. In normal DNS resolution, when a resolver attempts to resolve a domain name, it first queries the root, which provides the top-level domain. Next, it queries the top-level domain servers, which provide the domain\u2019s authoritative nameservers. Finally, it queries the authoritative nameservers for the domain to resolve the domain name. If the nameservers for a domain exist inside the domain itself, a glue record is needed to resolve the domain name.</p> <p>https://www.cloudflare.com/learning/dns/dns-records/</p>"},{"location":"domains.html","title":"Domains","text":""},{"location":"domains.html#domain-name","title":"Domain name","text":"<p>Simply put, a domain name (or just \u2018domain\u2019) is the name of a website. It\u2019s what comes after \u201c@\u201d in an email address, or after \u201cwww.\u201d in a web address. If someone asks how to find you online, what you tell them is usually your domain name. Domain names are typically broken up into two or three parts, each separated by a dot. To the left of the TLD is the second-level domain (2LD) and if there is anything to the left of the 2LD, it is called the third-level domain (3LD).  For Google\u2019s US domain name, \u2018google.com\u2019:</p> <ul> <li>\u2019.com\u2019 is the TLD (most general)</li> <li>\u2019google\u2019 is the 2LD (most specific)</li> </ul> <p>Difference between a domain name and a URL? A uniform resource locator (URL), sometimes called a web address, contains the domain name of a site as well as other information, including the protocol and the path. For example, in the URL \u2018https://example.com/learning/\u2019, example.com\u2019 is the domain name, while \u2018https\u2019 is the protocol and \u2018/learning/\u2019 is the path to a specific page on the website.</p>"},{"location":"domains.html#fqdn-fully-qualified-domain-name","title":"FQDN - Fully qualified domain name","text":"<p>Check - https://en.wikipedia.org/wiki/Fully_qualified_domain_name</p> <p>A fully qualified domain name (FQDN) is a part of the uniform resource locator (URL). As the name suggests, it is the full name of an entity in the internet framework, including a host and a computer.</p> <p>FQDNs are usually used in any interaction on the internet as they are easier to remember than IP addresses. Below are several scenarios of when to use an FQDN:</p> <ul> <li> <p>Getting an SSL certificate. A secure sockets layer (SSL) protects a connection between a web server and a browser. An SSL certificate is issued to an FQDN, so you may not be able to use SSL services properly without it.</p> </li> <li> <p>Connecting to a remote host. You can make a remote host or a virtual machine by specifying any FQDN, enabling the DNS to look at its DNS table and locate the server. If you use only the hostname to connect to a server, your application may not be able to resolve the hostname.</p> </li> <li> <p>Accessing a specific domain service or protocol. Activities transferring information across a network generally involve the DNS, including pointing to an FQDN. An example is when you connect to a File Transfer Protocol (FTP) or an email server.</p> </li> <li> <p>Migrating to a new server. If you want to migrate your service to a server with a different IP address, using an FQDN instead of an IP address lets you quickly change the DNS record and reduce outages in the IP address changes.</p> </li> </ul>"},{"location":"domains.html#ssl","title":"SSL","text":"<p>SSL, or Secure Sockets Layer, is an encryption-based Internet security protocol. SSL encrypts data that is transmitted across the web. SSL is the predecessor to the modern TLS (Transport Layer Security) encryption used today (but people still refer to it as SSL).</p> <p>Anyone who tries to intercept this data will only see a garbled mix of characters that is nearly impossible to decrypt.</p> <p>SSL initiates an authentication process called a handshake between two communicating devices to ensure that both devices are really who they claim to be. SSL also digitally signs data in order to provide data integrity, verifying that the data is not tampered with before reaching its intended recipient.</p> <ul> <li>Secure Socket Layer</li> <li>SSL encrypts data that is transmitted across the web</li> <li>It initiates an auth process called a handshake between the two communicating devices to make sure that both are what they claim to be</li> <li>It\u2019s now TLS, but still called SSL</li> </ul> <p>https://www.cloudflare.com/learning/ssl/what-is-ssl/</p>"},{"location":"emails.html","title":"Email","text":""},{"location":"emails.html#keywords","title":"Keywords:","text":"<ul> <li>MUA (Mail User Agent) - Webmails, Clients (Outlook, Thunderbird)</li> <li>MDA (Mail Delivery Agent)</li> <li>MTA (Mail Transfer Agent)</li> <li>SMTP (Simple Mail Transfer Protocol)</li> <li>IMAP (Internet Message Access Protocol)</li> <li>POP3 (Post Office Protocol 3)</li> <li>MX records (Mail Exchange Records)</li> <li>SPF (Sender Policy Framework)</li> <li>DKIM (Domain Keys Identified Mail)</li> <li>DMARC (Domain-based Message Authentication and Conformance)</li> </ul>"},{"location":"emails.html#process","title":"Process","text":""},{"location":"emails.html#mail-user-agent","title":"Mail User Agent:","text":"<p>MUA (Mail User Agent) or an email client is a software or a web application that allows users to compose, send, and manage their emails. Examples include Microsoft Outlook, Mozilla Thunderbird, and Apple Mail (software application) and RoundCube, SquirrelMail and Horde (web applications). </p> <p>Our customers can also send emails through their websites using default PHP mailer or SMTP plugins - form submissions are one example. If form submission is set up, their customers will fill out the form and the website will send out an email automatically as a \u201cquasi\u201d MUA.</p>"},{"location":"emails.html#mail-transfer-agentsmtp","title":"Mail Transfer Agent/SMTP:","text":"<p>Once an email is sent, an email client will communicate with an MTA - Mail Transfer Agent - the SMTP server. </p> <p>SMTP server utilizes software like exim, qmail or postifx to send a message to the recipient's mail server. The SMTP server will take an email message from a client and prepare it for a delivery by adding necessary headers like sender and recipient addresses and append the details required for a transmission. </p> <p>Afterwards, the SMTP server performs a DNS lookup to find the recipient server. Once the recipient\u2019s mail server is identified, your email server establishes a connection with it using the SMTP (Simple Mail Transfer Protocol) which facilitates the transmission of email messages between servers over ports  25/465/587. The email message is transferred from the sender's server to the recipient's server through this connection.</p> <p>The recipient's SMTP server receives incoming email messages from sender's SMTP server and verifies the validity of the email through various checkups such as:</p> <ul> <li>DNS record verification - SPF, DKIM, DMARC, PTR</li> <li>Server side SPAM rules</li> </ul>"},{"location":"emails.html#mail-delivery-agent","title":"Mail Delivery Agent:","text":"<p>When the validity of the email is verified, recipient SMTP server will invoke MDA like Dovecot to store the incoming email in the proper user's mailbox.  Once the email is delivered, MUA utilizes IMAP/POP3 protocols to retrieve emails from a mail server for the user.</p>"},{"location":"emails.html#pop3","title":"POP3","text":"<p>Post Office Protocol 3 is an email protocol that clients use to retrieve email from a mail server. POP3 clients connect, retrieve all messages, store them on the client computer, and finally delete them from the server (although there is an option for email clients to leave the message on the server or simply download a local copy). POP3 treats the mailbox as a single store, and has no concept of folders. It also provides a completely static view of the current state of the mailbox and does not provide a mechanism to show any external changes in state during the session.</p> <p>This design of POP and its procedures was driven by the need of users having only temporary Internet connections, such as dial-up access, allowing these users to retrieve email when connected, and subsequently to view and manipulate the retrieved messages when offline. A POP3 server listens on port number 110 for service requests or port number 995 for secure connection (POP3S).</p>"},{"location":"emails.html#imap","title":"IMAP","text":"<p>The Internet Message Access Protocol allows a client to access and manipulate electronic mail messages on a server, as well as manipulation of mailboxes\u00a0 in a way that is functionally equivalent to local folders. It includes operations for creating, deleting and renaming mailboxes; checking for new messages; removing messages permanently; setting and clearing flags (read, replied to, forwarded, deleted etc); searching; and selective fetching of message attributes, texts and portions thereof. IMAP4 server listens on port 143 which is an unsecure channel or port 993 which is an implicit TLS port.</p> <p>Visual ![[Mail delivery.png]]</p>"},{"location":"emails.html#troubleshooting-email-delivery-failure","title":"Troubleshooting email delivery failure:","text":"<p>Each step of this process can be a potential point of failure (that's why emails are so hard to troubleshoot). </p> <ol> <li>MUA:      Confirm with the client how their emails are being sent, is it an email or is it a form submission?          If it's an email, which email client are they using? Have they tried using the webmail client we offer?          If it's a form submission, how is it setup? Are they using a default PHP mailer or are they using an SMTP plugin? Access the admin page and review the configuration they have setup.          Check with them which mailbox the email is sent from and whether that is the only affected mailbox. Create a test mailbox and send an email to check whether the message is going through or not by sending it to your account.</li> <li>MTA:      Check for delivery failures in the logs;         Once you know which domain/mailbox are affected, you will be grepping the logs:         <code>$ cat /var/log/send/current | tai64nlocal | grep -iC 5 &lt;domain.com&gt;</code>          This command will allow you to check for emails that were sent from a particular domain.          # Side note - it is also possible to check cat /var/log/smtp/current log, however this log won't reveal much of anything. For basic troubleshooting, check the send log.</li> <li>MDA:      On managed apps we use dovecot. You can check the dovecot logs for information such as whether the user logging in is using IMAP/POP3 connection for example.         <code>cat /var/log/dovecot/dovecot.log</code></li> </ol>"},{"location":"emails.html#breakdown-of-the-mailing-process-using-qmail","title":"Breakdown of the mailing process using qmail:","text":"<p>Example of qmail log:</p> <pre><code>$ cat /var/log/send/current | tai64nlocal | grep 574692321\n2023-07-26 14:28:27.917076500 info msg 574692321: bytes 16593 from &lt;outlook_553EE1FF76D81E16@outlook.com&gt; qp 5228 uid 108\n\n2023-07-26 14:28:27.920988500 starting delivery 373: msg 574692321 to local myspareparts.com-maurice.niccoli@myspareparts.com\n\n2023-07-26 14:28:27.921004500 status: local 1/10 remote 0/255\n\n2023-07-26 14:28:27.921011500 starting delivery 374: msg 574692321 to local myspareparts.com-ben.veldman@myspareparts.com\n\n2023-07-26 14:28:27.921023500 status: local 2/10 remote 0/255\n\n2023-07-26 14:28:28.014981500 delivery 374: success: vdelivermail:_valiases_processed/did_0+0+1/\n\n2023-07-26 14:28:28.014983500 status: local 1/10 remote 0/255\n2023-07-26 14:28:28.046694500 delivery 373: success: vdelivermail:_valiases_processed/did_0+0+1/\n\n2023-07-26 14:28:28.046768500 status: local 0/10 remote 0/255\n2023-07-26 14:28:28.046819500 end msg 574692321\n</code></pre> <p>Step by step breakdown:</p> <p><code>$ tail /var/log/send/current | tai64nlocal</code> Lookup command: - <code>tai64nlocal</code>  &lt;- Time formatting</p> <p><code>2023-07-26 14:28:27.917076500 info msg 574692321: bytes 16593 from &lt;outlook_553EE1FF76D81E16@outlook.com&gt; qp 5228 uid 108</code></p> <ul> <li><code>2023-07-26 14:28:27.917076500</code> &lt;- Timestamp</li> <li><code>msg 574692321</code>  &lt;- Message number that can be used to tie log entries together and follow the process of any given message in the queue.</li> <li><code>from &lt;outlook_553EE1FF76D81E16@outlook.com&gt;</code> &lt;- The address to which any bounce messages will be sent if any of the recipients are unable or unwilling to accept the message.</li> <li><code>qp 5228</code> &lt;- process ID of the qmail-queue process which added the message to the queue. It's used to link the qmail-queue and qmail-send logs together.</li> <li><code>uid 108</code> &lt;- numeric UID under which the qmail-queue process was running when the message was added to the queue. </li> </ul> <p><code>2023-07-26 14:28:27.920988500 starting delivery 373: msg 574692321 to local myspareparts.com-maurice.niccoli@myspareparts.com</code></p> <ul> <li><code>starting delivery 373</code> &lt;- Message delivery has been started. </li> <li><code>to local myspareparts.com-maurice.niccoli@myspareparts.com</code> &lt;- This message tells you whether this is a local or remote delivery and the recipient's mail address.</li> </ul> <p><code>2023-07-26 14:28:27.921004500 status: local 1/10 remote 0/255</code> </p> <ul> <li><code>status: local 1/10 remote 0/255</code> &lt;- Every time a delivery process starts or ends, this message is sent to the log. In this example there are 10 concurrent local delivery slots available and 1 of those slots is being used, and there are 255 concurrent remote delivery slots available and 0 of them are being used</li> </ul> <p><code>2023-07-26 14:28:28.014981500 delivery 374: success: vdelivermail:_valiases_processed/did_0+0+1/</code> </p> <ul> <li> <p><code>delivery 374: success: vdelivermail:_valiases_processed/did_0+0+1/</code> &lt;- The delivery attempt 374 is finished and it was successful. The delivery code can be one of the following:</p> <ul> <li><code>success</code> &lt;- For a local delivery, qmail-local was able to successfully process a delivery. This can mean one of three things:<ul> <li>Message was stored in one or more Maildirs, forwarded to zero or more other email addresses, or processed through zero or more programs. The extra info looks like <code>did_0+0+1</code> :<ul> <li>message was stored in 0 Maildirs</li> <li>message was forwarded to 0 mail addresses</li> <li>message was processed by 1 program.</li> </ul> </li> </ul> </li> <li> <p><code>success</code> &lt;-For a remote delivery, qmail-remote was able to contact a remote SMTP server and that server accepted the message. That's all it tells you, it does not guarantee that the other server will be able to deliver the message to the correct mailbox, only that it accepted the responsibility for getting the message to where it needs to be.</p> </li> <li> <p><code>deferral</code>&lt;- There was some kind of a temporary error which prevented the delivery from succeeding, but the delivery will be tried again after a delay. The extra information will usually tell us why the message was not accepted.</p> </li> <li> <p><code>failure</code> &lt;-Delivery did not succeed and there isa good reason to believe that it will never succeed, so qmail-send won't attempt to send a message again.  </p> </li> </ul> </li> <li> <p><code>2023-07-26 14:28:28.046768500 status: local 0/10 remote 0/255</code>2023-07-26 14:28:28.046819500 end msg 574692321` &lt;- The queue is empty and the message is being deleted from the queue. </p> </li> </ul> <p>Log locations:  - qmail-send <code>/var/log/send/current</code> - qmail-smtp inc&amp;out <code>/var/log/smtp/current</code> - IMAP  (legacy SIP) <code>/var/log/imap4-ssl/current</code> - POP  (legacy SIP)<code>/var/log/pop3-ssl/current</code> - POP and IMAP (cloudhost and recent dedicated servers) <code>/var/log/dovecot</code> - Inbound SpamAssassin scoring <code>/var/log/maillog</code></p>"},{"location":"internet-models.html","title":"OSI Seven-Layer Model","text":"<p>OSI 7-layer model is a conceptual network format which encourages modular design in networking, meaning that each layer has as little to do with the operation of other layers as possible.</p> <p>Mnemonic: Please Do Not Throw Sausage Pizza Away. </p> <p>The seven layers include:</p> <ul> <li>Layer 7: Application</li> <li>Layer 6: Presentation</li> <li>Layer 5: Session</li> <li>Layer 4: Transport</li> <li>Layer 3: Network\u00a0</li> <li>Layer 2: Data Link</li> <li>Layer 1: Physical</li> </ul>"},{"location":"internet-models.html#layer-7-application-layer","title":"Layer  7. Application layer:","text":"<p>Being the topmost layer of the OSI model, this is the only layer that directly interacts with data from the user. Software applications like web browsers and email clients rely on the application layer to initiate communications. </p> <p>The software applications are not part of the application layer by themselves, but rather the application layer is responsible for the protocols and data manipulation that the software relies on to present meaningful data to the user.</p> <p>Once the user's data has been gathered, application layer will make a connection with the bottom layer - presentation layer for further manipulation. </p> <p>Application layer protocols:</p> <ul> <li>[[HTTP &amp; HTTPS]]</li> <li>[[FTP]]</li> <li>[[4. Emails - Sending, records, software (qmail vs dovecot, their log locations)#Mail Transfer Agent/SMTP|SMTP]]</li> <li>[[2. DNS (full)#What is DNS?|DNS]] </li> <li>[[DHCP]]</li> <li>[[SSH]]</li> </ul>"},{"location":"internet-models.html#layer-6-presentation-layer","title":"Layer 6. Presentation layer:","text":"<p>The presentation layer is responsible for handling the syntax and semantics of the information exchanged between network devices. </p> <p>It handles data conversion, encryption and compression.</p> <ul> <li>Data conversaon </li> <li>Data Encryption </li> <li>Data compression </li> </ul>"},{"location":"internet-models.html#layer-5-session-layer","title":"Layer 5. Session layer","text":"<p>In a network, multiple applications running on different systems may need to communicate with one another. This process is called a session, and the Session layer handles these interactions. It provides the mechanisms for establishing a session between applications, maintaining the session and ending the session once the communication is complete. It also provides mechanisms for synchronization and recovery in case of communication failure or interruptions.\u00a0</p> <p>Lets say we are running an email client, a web browser and a torrent applications at the same time. Each of these applications will be using a different session, which is managed by this layer. This is the reason why we can at the same time have a browser, mail client and torrent client open for example. This layer will assign each of these applications a session so that the data can be managed accordingly. </p>"},{"location":"internet-models.html#layer-4-transport-layer-segmentation-and-reassembly","title":"Layer 4: Transport Layer - Segmentation and Reassembly","text":"<p>Unlike the name would suggest, transport layer does not transport data between different devices. Transport layer's job is to break down data from the upper layers into digestible chunks and to append header with source and destination [[PORTS|port]] so that the machines on a network know which service said data chunks are meant for.</p> <ul> <li>Source port is required on the source machine in cases where we have multiple applications using the same protocol. If, for example, we had multiple browsers installed, when we try to access a website on one through HTTP, we do not want the result to be opened in another browser. Source port will be a random number between 1024-65535.</li> <li>Destination port will depend on which service we require from the destination machine, and will be provided by the application layer. It will most commonly be one of the well known ports (1-1024).</li> </ul> <p>This process is called segmentation, and said chunks are called segments or datagrams.</p> <p>The receiving system then does the reassembly of these segments - recognizes the incoming packets as one data transmission, reassembles the packets correctly based on the information included in the packets by the sending system and verifies that all the packets for that piece of data arrived in good shape.\u00a0</p> <p>The primary functions of the Transport Layer are:</p> <ul> <li> <p>To enable efficient network transmission, the Transport Layer splits the total amount of data it gets from the applications running at the top layers into smaller units known as segments. The Transport Layer puts these bits back together into the original data stream at the other end.</p> </li> <li> <p>In situations when organised data transfer is required, the Transport Layer creates a connection between the source and the destination. In order to create the proper parameters and guarantee that both systems are prepared to communicate data, a handshake protocol is established. When the data transfer is complete, the Transport Layer closes the connection.</p> </li> <li> <p>The transport layer also assures dependable data transmission. Receiving acknowledgments, or ACK bits, is how this is accomplished. While waiting for the recipient to acknowledge the parts it sent, the sender keeps an eye on them. Any damaged segments are retransmitted by the sender if they receive an acknowledgment.</p> </li> <li> <p>Flow regulation - In order to prevent data overload, transport layer regulates the data transfer rate. </p> </li> <li> <p>Both error detection and repair are handled by the transport layer. Checksums are one of these techniques for error detection. By computing and validating checksums, it can ascertain whether data was tampered with during transmission. The Transport Layer will request retransmission if it finds anything.</p> </li> </ul> <p>Depending on whether the connection favors performance or stability, we differentiate two transport layer protocols: - [[TCP vs UDP]]</p>"},{"location":"internet-models.html#layer-3-network-layer","title":"Layer 3: Network Layer","text":"<p>Because these segments will need to travel all over the Internet along different pathways, we need a mechanism that knows once the segment does arrive, which pathway it's supposed to be sent down to so that it all gets to the final destination. This is handled by the Network layer.</p> <p>Network layer will take the segment from the Transport layer, re-encapsulate it by adding a header to it which will have a source and destination IP address. We call this chunk a packet.</p> <p>By far the most common protocol that is used on the Network layer is IPv4 (but it's not the only one).</p> <p>Network Layer handles functions such as: - Assigning Logical Address to devices which are connecting to a network to send/receive data packets.  - Routing - process of identifying the best path to transmit the packets - Host-to-host delivery or Forwarding - process in which the network layer transmits or forwards the data via routers after determining the best path. - Logical subnetting - dividing a bigger network into smaller chunks so that IP addresses are used more efficiently.  - Network Address Translation (NAT) - process of converting any private IP address into a public IP address.</p>"},{"location":"internet-models.html#network-layer-protocols","title":"Network Layer protocols:","text":"<ul> <li>[[Internet Protocol]]</li> <li>[[ICMP]]</li> </ul>"},{"location":"internet-models.html#layer-2-data-link-layer","title":"Layer 2: Data-Link Layer","text":"<p>When we say \"link\", we mean two devices connecting together. Everything up to this layer was a machine readable data. Data-Link layer has a job to take said data and connect it to the last layer - Physical layer. It does this by taking the packet provided by the Network layer and encapsulates it in a frame. </p> <p>Data-Link does splits its job into  two sublayers: - Logical Link Control (LLC) layer talks to the operating system through drivers and handles multiple network protocols and provides flow control. - Media Access Control (MAC) layer creates and addresses the frame. It adds NIC\u2019s MAC address and attaches MAC addresses to the frame, adds and checks the FCS and ensures that frames are sent along the network cabling.\u00a0</p> <p>A frame will consist of a header and a trailer attached to it. Trailer exists because much like all the other layers, Data-Link is also governed by protocols (Ethernet being the most common). </p> <p>Data transmission involves a stream of signals through a physical device, and in nature there are many signals which are just static noise. In order to differentiate data transferred between devices from a static noise, we attach a trailer to the packet. With it, destination device can recognize said stream of data and know how to handle it.</p>"},{"location":"internet-models.html#layer-1-physical-layer","title":"Layer 1: Physical layer","text":"<p>Network needs a physical channel through which the data can be transferred. Most common type is the UTP cable (unshielded twisted pair) which can transmit and receive data, as well as a central box (Hub/Switch) that handles a flow from one machine to another. Each system on a network has a cable connected to the central box.</p> <p>Network Interface Card (NIC) serves as the interface between the PC and the network. Each NIC has a unique identifier with a 48-bit value called media access control address (MAC address) so data is transferred to the right system. No two NICs ever share the same MAC address. Those numbers are provided by Institute of Electrical and Electronics Engineers (IEEE) to the companies making NICs, which often print the numbers onto the device itself using hexadecimal notation.  - Example: 00\u201340\u201305\u201360\u20137D\u201349</p> <p>First six digits in MAC address represent the number of the NIC manufacturer and they are referred to as Organizationally Unique Identifier (OUI) while the last six digits represent the unique serial number for the NIC and are referred to as device ID. Nomenclature for MAC addresses is also known as MAC-48 and EUI-48 (Extended Unique Identifier, chosen for trademarking purposes).\u00a0</p> <p>NICs transfer the information through the UTP cable in the form of binary data that is broken down into discrete chunks called frames. The NICs create and send, as well as receive and read these frames. Different frames are used on different networks and all NICs on the same network must use the same frame type to communicate with other NICs.</p> <p>(Optional)     Frame begins with the MAC address of the NIC to which the data is to be sent, followed by the MAC address of the sending NIC. Next comes the Types\u00a0field which indicates the type of data transferred, followed by the Data field which contains the encapsulated information. Lastly, there is a special bit of checking information called frame check sequence. FCS uses a type of binary math called cyclic redundancy check (CRC) in order to verify that the data has arrived intact. Most wired connections hold up to 1500 bytes of data.\u00a0</p> <p>When a system sends a frame out on the network, the frame goes into the central box. What happens from that point depends on the type of central box. - Hub could make a copy of the frame and send it to all the connected ports except for the port from which the message originated. Only the NIC to which the frame was addressed would process that frame and the others would drop it when they saw it wasn\u2019t addressed to their MAC addresses. - Switch sent a frame only to the interface associated with the destination of the MAC address.</p> <p>(Optional)     In situations where NIC doesn\u2019t know the MAC address of another NIC, they send a broadcast onto the network to ask for it. If a NIC sends a frame using a broadcast address (MAC address FF-FF-FF-FF-FF-FF), that frame is processed by every single NIC on that network. That broadcast frame\u2019s data will contain a request for a system\u2019s MAC address. Without knowing the MAC address to begin with, the requesting computer will use an IP address to pick the target computer out of the crowd. The system that is sought will read the request in the broadcast frame and respond its MAC address.</p> <p>When the frame finally arrives to the destination machine, the entire process will be reversed. - Data Link will remove the header and a trailer from the frame and pass the packet along to the Network layer. - Network layer will remove the header and pass the packet to the Transport layer. - Transport layer will read the destination port and transfer the frame to the appropriate service in the upper layers.</p> <p>PDU - protocol data unit</p>"},{"location":"internet-models.html#tcpip-model","title":"TCP/IP model","text":"<p>The reason why TCP/IP model has this name is because the persons who developed it focused primarily on these two protocols. Back in the day of Arpanet, they needed to be sure that the data was reliable.</p>"},{"location":"internet-models.html#the-application-layer","title":"The Application layer","text":"<p>The Application layer combines the top three layers of the OSI model and its responsible for providing network services and applications to end-users.</p> <p>Although we can say that the OSI Presentation layer is part of the TCP/IP Application layer, no application requires any particular form of presentation as seen by the OSI model. Applications in TCP/IP already use standardized formats that everyone understands.\u00a0</p> <p>Furthermore, Session Layer's responsibilities are also handled by applications themselves - every application has to be able to initiate, control and disconnect from a remote system. There is no clearly defined way to do this and each TCP/IP application uses its own methods.</p> <p>All applications can talk to the network, so long they are part of the network. They also need to be part of the network to function: Web browsers, e-mail clients, multiplayer games etc.</p> <p>Just like in the OSI model, the Application Layer will produce a stream of data which will be handed off to the layer below it.</p>"},{"location":"internet-models.html#the-transport-layer","title":"The Transport Layer","text":"<p>The Transport Layer is equivalent to the OSI Transport layer. It\u2019s responsible for providing reliable end-to-end communication between applications running on different hosts. </p> <p>Much like it's OSI equivalent, Transport Layer will produce segments from the data that the Application Layer provided. It doesn't care how data is delivered because at some point of the data transfer, the destination device will have to know how to handle the data which Application Layer produced.</p> <p>Transport Layer includes two protocols - Transmission Control Protocol (TCP) and User Datagram Protocol (UDP).\u00a0</p> <ul> <li> <p>TCP is a connection-oriented protocol that provides reliable, ordered and error checked delivery of data between applications. As a consequence of adding all of those mechanisms, the data transmission will be reliable but slow.</p> </li> <li> <p>UDP is a connectionless communication that provides an unreliable, unordered and unchecked delivery of data. The trade-off is that the data transmission is much faster because it doesn't have to append extra bits to the segment. It\u2019s used with software like VoIP or video streaming.</p> </li> </ul> <p>TCP segments include fields:</p> <ul> <li>Destination port</li> <li>Source port</li> <li>Sequence number</li> <li>Checksum</li> <li>Flags</li> <li>Acknowledgement</li> <li>Data</li> </ul> <p>UDP on the other hand also gets the data from the Application layer and adds port and length numbers, as well as a checksum to create a container called a UDP datagram. UDP doesn\u2019t care if the receiving computer gets all its data, which is why UDP datagram lacks most of the fields found in TCP segments.</p> <p>In summary, data arrives from the Application layer which is then broken up into fragments, given destination, source and sequence numbers and then shipped to the Internetworking Layer to be wrapped into an IP packet.\u00a0</p>"},{"location":"internet-models.html#the-internetworking-layer","title":"The Internetworking Layer","text":"<p>The Internetworking layer is equivalent to OSI Network Layer and is responsible for handling logical addressing and routing (forwarding). </p> <p>The main protocol used on this layer Internet Protocol which provides a unique IP address to each device on the network. Any device or protocol that deals with pure IP packets sits on the Internetworking Layer. </p> <p>The Internet layer doesn\u2019t care what type of data the IP packet carries, nor does it care whether the data gets there in good order or not. That is handled by the Transport layer.</p> <p>Internetworking layer will take the segment provided by the Transport Layer and will create a packet.</p>"},{"location":"internet-models.html#network-access-layer","title":"Network Access Layer","text":"<p>Network Access Layer groups up the last two layers of the OSI model - Data-Link and Physical. The keyword in this layer is access - this layer deals with any physical (hardware) part of the network.</p>"},{"location":"magento.html","title":"Magento","text":""},{"location":"magento.html#redis","title":"Redis","text":""},{"location":"magento.html#elasticsearch","title":"ElasticSearch","text":""},{"location":"ping-traceroute-netstat.html","title":"Basic tools for computer network analysis","text":""},{"location":"ping-traceroute-netstat.html#ping","title":"ping","text":""},{"location":"ping-traceroute-netstat.html#traceroute-tracepath","title":"traceroute &amp; tracepath","text":""},{"location":"ping-traceroute-netstat.html#netstat","title":"netstat","text":""},{"location":"ports.html","title":"Ports","text":"<p>Port is a logical connection used by programs and services to exchange information. It determines which program or service on a computer or server is going to be used.  All ports are identified by the unique number that ranges from 0-65535. </p> <p>Whenever a device attempts to make a connection to another device on the network, a port will be paired up with an IP address. An IP address will be used to determine the physical location of the server, while the port will determine which service that server wants to use. </p> <p>We can use Netstat utility (network statistics) in order to display current network connections and port activities on our computer. </p> <pre><code>sandar@nova:~$ netstat -n\nActive Internet connections (w/o servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State      \ntcp        0      0 192.168.1.110:22        192.168.1.103:42470     ESTABLISHED\ntcp6       0      0 192.168.1.110:80        192.168.1.107:62563     FIN_WAIT2  \ntcp6       0      0 192.168.1.110:80        192.168.1.107:62550     TIME_WAIT  \n</code></pre> <p>Port numbers are assigned by IANA - Internet assigned Numbers Authority. They are broken down into three categories:</p> Port numbers Port names 0-1023 System/Well Known Ports 1024-49151 User/Registered ports 49152-65535 Dynamic/Private ports <p>First two categories are used by the server to which our device connects to, while the last one is the one that device assigns itself during the session.</p> Application TCP/UDP Port Notes FTP TCP 20/21 File transfer SSH TCP 22 Secure remote control Telnet TCP 23 Remote control SMTP(S) TCP 25/587 Sending emails DNS UDP 53 Naming DHCP UDP 67/68 Assigns IPs HTTP(S) TCP 80/443 Web(secure) POP3(S) TCP 110/995 Email retrieval(secure) IMAP4 TCP 143/993 Email retrieval (secure) MySQL TCP 3306 Database server"},{"location":"ssl.html","title":"SSL","text":""},{"location":"ssl.html#ssl","title":"SSL","text":"<p>SSL, or Secure Sockets Layer, is an encryption-based Internet security protocol. SSL encrypts data that is transmitted across the web. SSL is the predecessor to the modern TLS (Transport Layer Security) encryption used today (but people still refer to it as SSL).</p> <p>Anyone who tries to intercept this data will only see a garbled mix of characters that is nearly impossible to decrypt.</p> <p>SSL initiates an authentication process called a handshake between two communicating devices to ensure that both devices are really who they claim to be. SSL also digitally signs data in order to provide data integrity, verifying that the data is not tampered with before reaching its intended recipient.</p> <ul> <li>Secure Socket Layer</li> <li>SSL encrypts data that is transmitted across the web</li> <li>It initiates an auth process called a handshake between the two communicating devices to make sure that both are what they claim to be</li> <li>It\u2019s now TLS, but still called SSL</li> </ul> <p>https://www.cloudflare.com/learning/ssl/what-is-ssl/</p> <p>SSL (Secure Sockets Layer) also referred to as the TLS (Transport Layer Security) is a form of asymmetric encryption of data on the internet. </p> <p>Originally, data on the Web was transmitted in plaintext that anyone could read if they intercepted the message. For example, if a consumer visited a shopping website, placed an order, and entered their credit card number on the website, that credit card number would travel across the Internet unconcealed. SSL was created to correct this problem and protect user privacy. </p> <p>By encrypting any data that goes between a user and a web server, SSL ensures that anyone who tries to intercept this data will only see a garbled mix of characters that is nearly impossible to decrypt. </p> <p>What is an SSL certificate? An SSL certificate is a text file hosted in a website's origin server which contains the website's public key and devices attempting to communicate with the origin server will reference this file to obtain the public key and verify the server's identity. </p> <p>In order to get an SSL certificate, a Certificate Signing Request (CSR) has to be created first. Information that CSR includes is: * Fully-Qualified Domain Name (FQDN) * Legal name of the organization * Division of the Organization * City * Region * Country * Email address</p> <p>Once a CSR is created, an SSL certificate can then be purchased from the CA. A CA is an outside organization, a trusted third party, that generates and gives out SSL certificates. Once the certificate is issued, it needs to be installed and activated on the website's origin server and when it's activated on the origin server, the website will be able to load over HTTPS and all traffic to and from the website will be encrypted and secure.</p> <p>SSL certificates include the following information in a single data file: * The\u00a0domain name that the certificate was issued for * Which person, organization, or device it was issued to * Which certificate authority issued it * The certificate authority's digital signature * Associated subdomains * Issue date of the certificate * Expiration date of the certificate * The public key (the private key is kept secret)</p> <p>The public and private keys used for SSL are essentially long strings of characters used for encrypting and signing data. Data encrypted with the public key can only be decrypted with the private key during the process known as an SSL handshake:</p> <ul> <li>Step 1: The SSL/TLS client will send the server a \u201cClientHello\u201d message that includes information about the browser, the OS, SSL/TLS version and the encryption algorithm that the client supports.</li> <li>Step 2: The SSL/TLS server sends back a \u201cServerHello\u201d message with an agreement on which encryption algorithm they should use during the session, it's digital certificate containing the domain name and certificate authority, and the public key they would use for encryption.</li> <li> <p>Step 3: The client then confirms that the web server\u2019s digital certificate is valid and issued by a CA. </p> <p>Technically, anyone can create their own SSL certificate by generating a public-private key pairing and including all the information mentioned above. Such certificates are called self-signed certificates because the digital signature used, instead of being from a CA, would be the website's own private key.</p> <p>But with self-signed certificates, there's no outside authority to verify that the origin server is who it claims to be. Browsers don't consider self-signed certificates trustworthy and may still mark sites with one as \"not secure,\" despite the https:// URL. They may also terminate the connection altogether, blocking the website from loading.</p> </li> <li> <p>Step 4: If the certificate is valid, client extracts the public key and generates a new key for that particular session, then encrypts the session key with the public key and sends it back to the server.</p> </li> <li>Step 5: The SSL/TLS server decrypts the session key using its private key.</li> <li>Step 6: Both the client and the server now use the session key to communicate.</li> <li>Step 7: Finally, both the server and the client now exchange the finished messages using the new session key. This message states that the handshake is complete. </li> </ul> <p>Types of SSL certificates: * Number of sites they cover:     * Single domain     * Wildcard - includes the main domain and all of the subdomains     * Multi-domain - applies to multiple unrelated domains * Validation level:     * Domain validation - business has to prove they control the domain     * Organization validation - CA directly contacts a person or business requesting the certificate     * Extended validation - full background check of an organization </p> <p>SSL verification methods: * HTTP validation method:     Inside of docroot create a directory .well-known/pki-validation/gsdv.txt, and inside of it add the metatag that SSL provides * Email verification * DNS verification</p>"},{"location":"wordpress.html","title":"WP-CLI","text":""}]}